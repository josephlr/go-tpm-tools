package server

import (
	"bytes"
	"crypto"
	"crypto/sha1"
	"crypto/sha256"
	"errors"
	"fmt"

	"github.com/google/certificate-transparency-go/x509"
	"github.com/google/go-attestation/attest"
	tpmpb "github.com/google/go-tpm-tools/proto"
	"github.com/google/go-tpm/tpm2"
)

// GetMachineState extends ParseAndVerifyEventLog and returns a MachineState proto
// from the raw events, containing:
// - PlatformState
//   - Firmware version
// 	 - (GCE-only) Confidential computing technology used
// - Secure Boot state
//	 - Enabled
// 	 - db
//   - dbx
//   - Authority entries
//
// It is the caller's responsibility to call proto.Verify with those PCRs,
// a trusted public key, and a quote using the private part of the trusted key
// to ensure that the PCRs are generated by a known TPM.
func GetMachineState(rawEventLog []byte, pcrs *tpmpb.Pcrs) (*tpmpb.MachineState, error) {
	attestEvents, err := parseVerifyHelper(rawEventLog, pcrs)
	if err != nil {
		return nil, err
	}
	sbState, err := attest.ParseSecurebootState(attestEvents)
	if err != nil {
		return nil, fmt.Errorf("failed to parse Secure Boot config: %v", err)
	}
	protoSbState, err := convertToProtoSecureBootState(sbState)
	if err != nil {
		return nil, err
	}

	platform, err := parsePlatformState(attestEvents)
	if err != nil {
		return nil, fmt.Errorf("failed to parse platform config: %v", err)
	}
	return &tpmpb.MachineState{
		Platform:   platform,
		SecureBoot: protoSbState,
		RawEvents:  convertToProtoEvents(attestEvents),
	}, nil
}

// ParseAndVerifyEventLog parses a raw event log and replays the parsed event
// log against the given PCR values. It returns the events verified
// particular PCR indexes/digests and an error if the replay for any PCR
// index does not match the provided value.
//
// It is the caller's responsibility to call server.Verify with those PCRs,
// a trusted public key, and a quote using the private part of the trusted key
// to ensure that the PCRs are generated by a known TPM.
//
// Most users should use the proto.GetMachineState and the MachineState proto
// rather than the raw event log events, as even replayed event logs can be misused.
// See https://github.com/google/go-attestation/blob/master/docs/event-log-disclosure.md
// for more details.
func ParseAndVerifyEventLog(rawEventLog []byte, pcrs *tpmpb.Pcrs) ([]*tpmpb.Event, error) {
	attestEvents, err := parseVerifyHelper(rawEventLog, pcrs)
	if err != nil {
		return nil, err
	}

	return convertToProtoEvents(attestEvents), nil
}

func parseVerifyHelper(rawEventLog []byte, pcrs *tpmpb.Pcrs) ([]attest.Event, error) {
	attestPcrs, err := convertToAttestPcrs(pcrs)
	if err != nil {
		return nil, fmt.Errorf("received bad PCR proto: %v", err)
	}
	eventLog, err := attest.ParseEventLog(rawEventLog)
	if err != nil {
		return nil, fmt.Errorf("failed to parse event log: %v", err)
	}
	return eventLog.Verify(attestPcrs)
}

func convertToAttestPcrs(pcrProto *tpmpb.Pcrs) ([]attest.PCR, error) {
	if len(pcrProto.GetPcrs()) == 0 {
		return nil, errors.New("no PCRs to convert")
	}
	hash := tpm2.Algorithm(pcrProto.GetHash())
	cryptoHash, err := hash.Hash()
	if err != nil {
		return nil, err
	}

	attestPcrs := make([]attest.PCR, 0, len(pcrProto.GetPcrs()))
	for index, digest := range pcrProto.GetPcrs() {
		attestPcrs = append(attestPcrs, attest.PCR{
			Index:     int(index),
			Digest:    digest,
			DigestAlg: cryptoHash,
		})
	}
	return attestPcrs, nil
}

func convertToProtoEvents(attestEvents []attest.Event) []*tpmpb.Event {
	protoEvents := make([]*tpmpb.Event, 0, len(attestEvents))
	for _, attestEvent := range attestEvents {
		protoEvents = append(protoEvents, &tpmpb.Event{
			Index:         uint32(attestEvent.Index),
			UntrustedType: uint32(attestEvent.Type),
			Data:          attestEvent.Data,
			Digest:        attestEvent.Digest,
		})
	}
	return protoEvents
}

func convertToProtoSecureBootState(attestSbState *attest.SecurebootState) (*tpmpb.SecureBootState, error) {
	if len(attestSbState.PreSeparatorAuthority) != 0 {
		return nil, fmt.Errorf("event log contained %v pre-separator authorities, which are not expected or supported", len(attestSbState.PreSeparatorAuthority))
	}
	return &tpmpb.SecureBootState{
		Enabled:   attestSbState.Enabled,
		Db:        convertToProtoDatabase(attestSbState.PermittedKeys, attestSbState.PermittedHashes),
		Dbx:       convertToProtoDatabase(attestSbState.ForbiddenKeys, attestSbState.ForbiddenHashes),
		Authority: convertToProtoDatabase(attestSbState.PostSeparatorAuthority, nil),
	}, nil
}

func convertToProtoDatabase(certs []x509.Certificate, hashes [][]byte) *tpmpb.Database {
	protoCerts := make([]*tpmpb.Certificate, 0, len(certs))
	for _, cert := range certs {
		protoCerts = append(protoCerts, &tpmpb.Certificate{
			Der: cert.Raw,
		})
	}
	return &tpmpb.Database{
		Certs:  protoCerts,
		Hashes: hashes,
	}
}

func parsePlatformState(events []attest.Event) (*tpmpb.PlatformState, error) {
	if len(events) == 0 {
		return nil, errors.New("no events supplied")
	}
	var (
		seenSeparator      bool
		scrtmVersionEvents [][]byte
		nonhostInfoEvents  [][]byte
	)
	startIndex := 0
	if uint32(events[0].Type) == NoAction {
		startIndex = 1
	}
	for _, event := range events[startIndex:] {
		if event.Index != 0 {
			continue
		}
		if err := verifyDigest(event); err != nil {
			return nil, fmt.Errorf("invalid digest: %v, for event %v", err, event.Data)
		}
		switch uint32(event.Type) {
		case Separator:
			if seenSeparator {
				return nil, fmt.Errorf("invalid events: duplicate separator event")
			}
			seenSeparator = true
		case SCRTMVersion:
			scrtmVersionEvents = append(scrtmVersionEvents, event.Data)
		case NonhostInfo:
			nonhostInfoEvents = append(nonhostInfoEvents, event.Data)
		}
	}
	if len(scrtmVersionEvents) != 1 {
		return nil, fmt.Errorf("expected only one CRTM version event, got %v events", len(scrtmVersionEvents))
	}
	confTech, err := parseGceConfidentialTechnology(nonhostInfoEvents)
	if err != nil {
		return nil, err
	}
	return &tpmpb.PlatformState{
		FirmwareVersion: scrtmVersionEvents[0],
		Technology:      confTech,
	}, nil
}

// TODO(wuale): taken from go-attestation. Consider exporting instead.
func verifyDigest(e attest.Event) error {
	if len(e.Digest) == 0 {
		return errors.New("no digests present")
	}

	switch len(e.Digest) {
	case crypto.SHA256.Size():
		s := sha256.Sum256(e.Data)
		if bytes.Equal(s[:], e.Digest) {
			return nil
		}
	case crypto.SHA1.Size():
		s := sha1.Sum(e.Data)
		if bytes.Equal(s[:], e.Digest) {
			return nil
		}
	default:
		return fmt.Errorf("verify failed: unknown hash of length %d", len(e.Digest))
	}

	return fmt.Errorf("digest (len %d) does not match", len(e.Digest))
}

func parseGceConfidentialTechnology(nonhostInfoEvents [][]byte) (tpmpb.GceConfidentialTechnology, error) {
	if len(nonhostInfoEvents) == 0 {
		return tpmpb.GceConfidentialTechnology_NONE, nil
	}
	for _, event := range nonhostInfoEvents {
		if len(event) == 32 && bytes.HasPrefix(event, GceMemoryEncryptionSignature) {
			confInfo := event[16]
			switch confInfo {
			case 0x0:
				return tpmpb.GceConfidentialTechnology_NONE, nil
			case 0x1:
				return tpmpb.GceConfidentialTechnology_AMD_SEV, nil
			default:
				return tpmpb.GceConfidentialTechnology_NONE, fmt.Errorf("parsing failed: unknown GCE confidential technology type: %v", confInfo)
			}
		}
	}
	return tpmpb.GceConfidentialTechnology_NONE, nil
}
